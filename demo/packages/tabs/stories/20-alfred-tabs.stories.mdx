import { Story, Meta, html, Preview } from '@open-wc/demoing-storybook';
import { LitElement } from '@lion/core';

import '../alfred-tabs.js';
import '../alfred-tab.js';
import '../alfred-tab-panel.js';

<Meta title="Intro/Tabs Example" parameters={{ component: 'alfred-tabs' }} />

# alfred Tabs

> This is not a real implementation!
>
> It is an example of how you can reuse the functionality of Lion to create your own Style System

`alfred-tabs` implements tabs view to allow users to quickly move between a small number of equally important views.

<Preview>
  <Story name="default">
    {html`
      <alfred-tabs>
        <alfred-tab slot="tab">Info</alfred-tab>
        <alfred-tab-panel slot="panel">
          Info page with lots of information about us.
        </alfred-tab-panel>
        <alfred-tab slot="tab">Work</alfred-tab>
        <alfred-tab-panel slot="panel">
          Work page that showcases our work.
        </alfred-tab-panel>
      </alfred-tabs>
    `}
  </Story>
</Preview>

## How to use

### Installation

```sh
npm i --save @lion/tabs;
```

### Usage

```js
import '@lion/tabs/alfred-tabs.js';
```

```html
<alfred-tabs>
  <alfred-tab slot="tab">Info</alfred-tab>
  <alfred-tab-panel slot="panel">
    Info page with lots of information about us.
  </alfred-tab-panel>
  <alfred-tab slot="tab">Work</alfred-tab>
  <alfred-tab-panel slot="panel">
    Work page that showcases our work.
  </alfred-tab-panel>
</alfred-tabs>
```

## Examples

### Selected Index

You can set the `selectedIndex` to select a certain tab.

<Preview>
  <Story name="Selected index">
    {html`
      <alfred-tabs .selectedIndex=${1}>
        <alfred-tab slot="tab">Info</alfred-tab>
        <alfred-tab-panel slot="panel">
          Info page with lots of information about us.
        </alfred-tab-panel>
        <alfred-tab slot="tab">Work</alfred-tab>
        <alfred-tab-panel slot="panel">
          Work page that showcases our work.
        </alfred-tab-panel>
      </alfred-tabs>
    `}
  </Story>
</Preview>

### Slots Order

The tab and panel slots are ordered by DOM order.

This means you can switch the grouping in your `alfred-tabs` from tab + panel to all tabs first or all panels first.

<Preview>
  <Story name="Slots order">
    {html`
      <alfred-tabs>
        <alfred-tab slot="tab">Info</alfred-tab>
        <alfred-tab slot="tab">Work</alfred-tab>
        <alfred-tab-panel slot="panel">
          Info page with lots of information about us.
        </alfred-tab-panel>
        <alfred-tab-panel slot="panel">
          Work page that showcases our work.
        </alfred-tab-panel>
      </alfred-tabs>
    `}
  </Story>
</Preview>

### Distribute New Elements

Below, we demonstrate on how you could dynamically add new tab + panels.

<Story name="Distribute new elements">
  {() => {
    const tagName = 'alfred-tabs-experimental';
    if (!customElements.get(tagName)) {
      customElements.define(
        tagName,
        class extends LitElement {
          static get properties() {
            return {
              __collection: { type: Array },
            };
          }
          render() {
            return html`
              <h3>Append</h3>
              <button @click="${this.__handleAppendClick}">
                Append
              </button>
              <alfred-tabs id="appendTabs">
                <alfred-tab slot="tab">tab 1</alfred-tab>
                <alfred-tab-panel slot="panel">panel 1</alfred-tab-panel>
                <alfred-tab slot="tab">tab 2</alfred-tab>
                <alfred-tab-panel slot="panel">panel 2</alfred-tab-panel>
              </alfred-tabs>
              <hr />
              <h3>Push</h3>
              <button @click="${this.__handlePushClick}">
                Push
              </button>
              <alfred-tabs id="pushTabs">
                <alfred-tab slot="tab">tab 1</alfred-tab>
                <alfred-tab-panel slot="panel">panel 1</alfred-tab-panel>
                <alfred-tab slot="tab">tab 2</alfred-tab>
                <alfred-tab-panel slot="panel">panel 2</alfred-tab-panel>
                ${this.__collection.map(
                  item => html`
                    <alfred-tab slot="tab">${item.button}</alfred-tab>
                    <alfred-tab-panel slot="panel">${item.panel}</alfred-tab-panel>
                  `,
                )}
              </alfred-tabs>
            `;
          }
          constructor() {
            super();
            this.__collection = [];
          }
          __handleAppendClick() {
            const tabsElement = this.shadowRoot.querySelector('#appendTabs');
            const c = 2;
            const n = Math.floor(tabsElement.children.length / 2);
            for (let i = n + 1; i < n + c; i += 1) {
              const tab = document.createElement('alfred-tab');
              tab.setAttribute('slot', 'tab');
              tab.innerText = `tab ${i}`;
              const panel = document.createElement('alfred-tab-panel');
              panel.setAttribute('slot', 'panel');
              panel.innerText = `panel ${i}`;
              tabsElement.append(tab);
              tabsElement.append(panel);
            }
          }
          __handlePushClick() {
            const tabsElement = this.shadowRoot.querySelector('#pushTabs');
            const i = Math.floor(tabsElement.children.length / 2) + 1;
            this.__collection = [
              ...this.__collection,
              {
                button: `tab ${i}`,
                panel: `panel ${i}`,
              },
            ];
          }
        },
      );
    }
    return html`
      <alfred-tabs-experimental></alfred-tabs-experimental>
    `;
  }}
</Story>

One way is by creating the DOM elements and appending them as needed.

Inside your `alfred-tabs` extension, an example for appending nodes on a certain button click:

```js
__handleAppendClick() {
  const tabsAmount = this.children.length / 2;
  const tab = document.createElement('alfred-tab');
  tab.setAttribute('slot', 'tab');
  tab.innerText = `tab ${tabsAmount + 1}`;
  const panel = document.createElement('alfred-tab-panel');
  panel.setAttribute('slot', 'panel');
  panel.innerText = `panel ${tabsAmount + 1}`;
  this.append(tab);
  this.append(panel);
}
```

The other way is by adding data to a Lit property where you loop over this property in your template.
You then need to ensure this causes a re-render.

```js
__handlePushClick() {
  const tabsAmount = this.children.length;
  myCollection = [
    ...myCollection,
    {
      button: `tab ${tabsAmount + 1}`,
      panel: `panel ${tabsAmount + 1}`,
    },
  ];
  renderMyCollection();
}
```

Make sure your template re-renders when myCollection is updated.

```html
<alfred-tabs id="pushTabs">
  ${myCollection.map(item => html`
  <alfred-tab slot="tab">${item.button}</alfred-tab>
  <alfred-tab-panel slot="panel">${item.panel}</alfred-tab-panel>
  `)}
</alfred-tabs>
```

## Rationale

### No separate active/focus state when using keyboard

We will immediately switch content as all our content comes from light dom (e.g. no latency)

See Note at <https://www.w3.org/TR/wai-aria-practices/#keyboard-interaction-19>

> It is recommended that tabs activate automatically when they receive focus as long as their
> associated tab panels are displayed without noticeable latency. This typically requires tab
> panel content to be preloaded.

### Panels are not focusable

Focusable elements should have a means to interact with them. Tab panels themselves do not offer any interactiveness.
If there is a button or a form inside the tab panel then these elements get focused directly.
